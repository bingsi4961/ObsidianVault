---
date : 2025-07-23 09:10
aliases:
  - 別名測試1
  - 別名測試2
tags:
  - 標籤測試1
  - 標籤測試2

---
# Metadata
Status :: 🌱
Note Type :: 📰
Source URL :: {文章 URL}
Author :: {作者名稱}
Topics :: {筆記跟什麼主題有關，用 `[Topic],[Topic]` 格式}

---
# 連結筆記
#### 📑 [[]]
#### 📑 [[]]

---

# Entity Framework - Select 投影 vs ThenInclude 差異筆記

## 核心概念差異

### Select 投影 vs ThenInclude 的根本差異

1. **回傳資料類型不同**
    - **Select 投影**: 回傳匿名物件或 DTO，無法存取原始實體
    - **ThenInclude**: 回傳完整的實體物件，可存取所有導航屬性

### 程式碼範例對比

```csharp
// Select 投影
var orderData = context.Orders
    .Select(o => new {
        OrderId = o.Id,
        CustomerName = o.Customer.Name
    })
    .ToList();
// 結果：orderData[0].Customer 無法存取！

// ThenInclude
var orders = context.Orders
    .Include(o => o.Customer)
    .ThenInclude(c => c.Address)
    .ToList();
// 結果：orders[0].Customer.Address.City 可以存取
```

## 使用情境選擇

### Select 投影適合的場景

- API 回傳特定資料
- 報表查詢
- 只需要部分欄位
- 唯讀操作

### ThenInclude 適合的場景

- 需要完整實體物件
- 後續要更新資料
- 需要存取多個導航屬性
- 商業邏輯處理

## 實際應用範例

### 場景 1: API 回傳資料 (推薦 Select 投影)

```csharp
// ✅ Select 投影更適合
public async Task<IActionResult> GetOrderList()
{
    var data = await context.Orders
        .Select(o => new {
            o.Id,
            o.OrderDate,
            CustomerName = o.Customer.Name,
            CustomerCity = o.Customer.Address.City
        })
        .ToListAsync();
    
    return Json(data); // 輕量、高效
}

// ❌ ThenInclude 會載入不需要的資料
public async Task<IActionResult> GetOrderListBad()
{
    var orders = await context.Orders
        .Include(o => o.Customer)
        .ThenInclude(c => c.Address)
        .ToListAsync();
    
    return Json(orders); // 會序列化所有屬性，包含不需要的
}
```

### 場景 2: 商業邏輯處理 (推薦 ThenInclude)

```csharp
// ✅ ThenInclude 更適合
public async Task ProcessOrder(int orderId)
{
    var order = await context.Orders
        .Include(o => o.Customer)
        .ThenInclude(c => c.Address)
        .Include(o => o.OrderItems)
        .FirstOrDefaultAsync(o => o.Id == orderId);
    
    // 可以存取完整的實體物件
    order.Customer.LastOrderDate = DateTime.Now;
    order.OrderItems.Add(new OrderItem { ... });
    
    await context.SaveChangesAsync(); // 可以更新
}

// ❌ Select 投影無法用於更新
public async Task ProcessOrderBad(int orderId)
{
    var orderData = await context.Orders
        .Select(o => new {
            o.Id,
            CustomerName = o.Customer.Name
        })
        .FirstOrDefaultAsync(o => o.Id == orderId);
    
    // 無法更新，因為不是實體物件
    // orderData.Customer.LastOrderDate = DateTime.Now; // 編譯錯誤！
}
```

## 效能差異分析

### Select 投影的優勢

```csharp
// 只傳輸需要的資料
var lightData = context.Orders
    .Select(o => new {
        o.Id,
        CustomerName = o.Customer.Name  // 只要這兩個欄位
    })
    .ToList();
```

### ThenInclude 的效能考量

```csharp
// 載入完整的實體物件
var fullData = context.Orders
    .Include(o => o.Customer)
    .ThenInclude(c => c.Address)
    .ToList();

// 會載入所有欄位：
// Order: Id, OrderDate, Amount, CreatedDate, UpdatedDate...
// Customer: Id, Name, Email, Phone, CreatedDate, UpdatedDate...  
// Address: Id, Street, City, Country, PostalCode, CreatedDate...
```

## SQL 語法比較

### Select 投影產生的 SQL

```sql
SELECT [o].[Id], [c].[Name] AS [CustomerName]
FROM [Orders] AS [o]
INNER JOIN [Customers] AS [c] ON [o].[CustomerId] = [c].[Id]
```

### ThenInclude 產生的 SQL

```sql
SELECT [o].[Id], [o].[OrderDate], [o].[Amount], [o].[CreatedDate], [o].[UpdatedDate],
       [c].[Id], [c].[Name], [c].[Email], [c].[Phone], [c].[CreatedDate], [c].[UpdatedDate],
       [a].[Id], [a].[Street], [a].[City], [a].[Country], [a].[PostalCode], [a].[CreatedDate]
FROM [Orders] AS [o]
LEFT JOIN [Customers] AS [c] ON [o].[CustomerId] = [c].[Id]
LEFT JOIN [Addresses] AS [a] ON [c].[AddressId] = [a].[Id]
```

## EF6 Include 行為重要說明 ⚠️

### EF6 自動載入機制

您完全正確！在 **Entity Framework 6.1.3** 中，EF6 會自動推斷並載入導航路徑上的中間實體：

```csharp
// ✅ 正確：只需要這一行
var orders = context.Orders
    .Include(o => o.Customer.Address)  // Customer 會自動被載入
    .ToList();

// ❌ 多餘：不需要額外 Include Customer
var orders = context.Orders
    .Include(o => o.Customer)           // 這行是多餘的！
    .Include(o => o.Customer.Address)   
    .ToList();
```

### 原理說明

當使用 `.Include(o => o.Customer.Address)` 時：

1. **EF6 會自動推斷路徑**：要存取 `Address`，必須先經過 `Customer`
2. **自動載入中間實體**：`Customer` 會自動被載入
3. **產生適當的 JOIN**：SQL 會包含必要的 JOIN 語句

### 實際產生的 SQL

```sql
SELECT 
    [o].[Id], [o].[OrderDate], [o].[CustomerId],
    [c].[Id], [c].[Name], [c].[Email],           -- Customer 自動被載入
    [a].[Id], [a].[Street], [a].[City]           -- Address 被載入
FROM [Orders] AS [o]
LEFT JOIN [Customers] AS [c] ON [o].[CustomerId] = [c].[Id]
LEFT JOIN [Addresses] AS [a] ON [c].[AddressId] = [a].[Id]
```

### 驗證方法

```csharp
// 測試程式碼
var orders = context.Orders
    .Include(o => o.Customer.Address)
    .ToList();

foreach (var order in orders)
{
    // 這些都不會觸發額外查詢
    Console.WriteLine($"訂單 ID: {order.Id}");
    Console.WriteLine($"客戶名稱: {order.Customer.Name}");      // Customer 已載入
    Console.WriteLine($"客戶城市: {order.Customer.Address.City}"); // Address 已載入
}
```

## 版本差異 (重要更正)

### Portal 系統環境

- **.NET Core 3.1**
- **Entity Framework Core 3.1.2**
- **現代語法支援**

### GTS 系統環境

- **.NET Framework 4.8**
- **Entity Framework 6.1.3**
- **傳統語法**

## 各版本語法差異

### EF Core 3.1.2 (Portal 系統)

```csharp
// 方法鏈式語法
var orders = context.Orders
    .Include(o => o.Customer)
    .ThenInclude(c => c.Address)
    .ThenInclude(a => a.Country)
    .ToList();

// 完整的異步支援
var orders = await context.Orders
    .Include(o => o.Customer)
    .ToListAsync();
```

### EF6.1.3 (GTS 系統)

```csharp
// 字串路徑語法
var orders = context.Orders
    .Include("Customer.Address.Country")
    .ToList();

// Lambda 表達式（EF6 會自動載入中間實體）
var orders = context.Orders
    .Include(o => o.Customer.Address.Country)  // 會自動載入 Customer 和 Address
    .ToList();

// ❌ 多餘的寫法（不需要分別 Include）
var orders = context.Orders
    .Include(o => o.Customer)                  // 不必要
    .Include(o => o.Customer.Address)          // 不必要
    .Include(o => o.Customer.Address.Country)
    .ToList();

// 基本異步支援
var orders = await context.Orders
    .Include(o => o.Customer.Address)  // Customer 會自動被載入
    .ToListAsync();
```

## 各版本最佳實務建議

### 在 GTS 系統中 (EF6.1.3)

```csharp
// ✅ 推薦：簡潔明確，自動載入中間實體
var orders = context.Orders
    .Include(o => o.Customer.Address)
    .ToList();

// ✅ 或者使用字串路徑
var orders = context.Orders
    .Include("Customer.Address")
    .ToList();

// ✅ 多層關聯也只需要一行
var orders = context.Orders
    .Include(o => o.Customer.Address.Country)  // Customer 和 Address 都會自動載入
    .ToList();
```

### 在 Portal 系統中 (EF Core 3.1.2)

```csharp
// ✅ 推薦：使用 ThenInclude 語法
var orders = await context.Orders
    .Include(o => o.Customer)
    .ThenInclude(c => c.Address)
    .ToListAsync();
```

## 專案應用範例

```csharp
// 推薦使用現代語法
public async Task<IActionResult> GetOrderData()
{
    var data = await _context.Orders
        .Include(o => o.Customer)
        .ThenInclude(c => c.Address)
        .Select(o => new {
            o.Id,
            CustomerName = o.Customer.Name,
            CustomerCity = o.Customer.Address.City
        })
        .ToListAsync();
    
    return Json(data);
}
```

### Portal 系統 (.NET Core 3.1 + EF Core 3.1.2)

```csharp
// 推薦使用現代語法
public async Task<IActionResult> GetOrderData()
{
    var data = await _context.Orders
        .Include(o => o.Customer)
        .ThenInclude(c => c.Address)
        .Select(o => new {
            o.Id,
            CustomerName = o.Customer.Name,
            CustomerCity = o.Customer.Address.City
        })
        .ToListAsync();
    
    return Json(data);
}
```

### GTS 系統 (.NET Framework 4.8 + EF6.1.3)

```csharp
// 使用 EF6 相容語法（正確版本）
public async Task<List<OrderDto>> GetOrderData()
{
    return await context.Orders
        .Include(o => o.Customer.Address)  // ✅ 只需要這一行，Customer 會自動載入
        .Select(o => new OrderDto {
            Id = o.Id,
            CustomerName = o.Customer.Name,
            CustomerCity = o.Customer.Address.City
        })
        .ToListAsync();
}
```

## 總結與選擇原則

### 功能定位差異

- **Select 投影**: 資料查詢，輕量高效，唯讀操作
- **ThenInclude**: 實體載入，功能完整，可更新操作

### 選擇原則

1. **需要更新資料** → 使用 ThenInclude
2. **只需讀取特定欄位** → 使用 Select 投影
3. **API 回傳資料** → 優先考慮 Select 投影
4. **業務邏輯處理** → 優先考慮 ThenInclude

### EF6 Include 重點提醒 ⚠️

在 EF6 中，**只需要 Include 最深層的實體**，中間的導航實體會自動載入：

```csharp
// ✅ 正確做法
.Include(o => o.Customer.Address)  // Customer 自動載入

// ❌ 冗餘做法
.Include(o => o.Customer)
.Include(o => o.Customer.Address)
```

### 共通優勢

兩者都能有效避免 N+1 查詢問題，但服務於不同的業務需求場景。

## 遷移考量

若未來將 GTS 系統升級至 EF Core，需注意：

- EF6 → EF Core 的語法差異
- 某些 EF6 功能在 EF Core 中可能不存在
- 效能特性可能有所不同