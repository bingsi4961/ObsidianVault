---
date: 2025-07-07 11:44
aliases: 
tags:
  - jQuery
  - AJAX
  - JavaScript
  - Promise

---
# Metadata
Status :: 🌱
Note Type :: 📰
Source URL :: {文章 URL}
Author :: {作者名稱}
Topics :: {筆記跟什麼主題有關，用 `[Topic],[Topic]` 格式}

---
# 連結筆記
#### 📑 [[HttpResponse]]

---
## 前言

這份筆記詳細記錄了 `$.ajax().done().fail()` 與 `Promise.then().catch()` 的差異，特別是在錯誤處理機制和資料傳遞模式上的重要區別。

## 第一章：物件型態與基礎概念

### $.ajax() 回傳的物件型態

當我們執行 `$.ajax()` 時，它回傳的是 **jQuery Deferred 物件**。這個物件是 jQuery 特有的 Promise-like 實作，雖然它遵循 Promise/A+ 標準，但它並非原生的 JavaScript Promise。Deferred 物件提供了兩套 API：傳統的 `.done()`, `.fail()`, `.always()` 方法，以及現代的 `.then()`, `.catch()`, `.finally()` 方法。

理解這個雙重性質很重要，因為傳統方法和現代方法在資料處理上有根本性的差異。傳統方法採用的是「觀察者模式」，而現代方法採用的是「鏈式傳遞模式」。

### Promise 回傳的物件型態

原生 JavaScript Promise 是 ES6 標準的異步處理物件，它只提供 `.then()`, `.catch()`, `.finally()` 等方法。Promise 的設計哲學是純粹的鏈式傳遞，每個 `.then()` 都會回傳一個新的 Promise，形成清晰的資料流向。

## 第二章：方法參數與資料型態的深度分析

### jQuery 傳統方法的豐富參數結構

**done() 方法接收三個參數：**

```javascript
$.ajax('/api/users')
.done(function(data, textStatus, jqXHR) {
    // data: 伺服器回傳的資料，jQuery 已自動根據 dataType 解析
    // textStatus: 字串，通常是 "success"，表示請求的狀態
    // jqXHR: jQuery XMLHttpRequest 物件，包含完整的請求資訊
    
    console.log('收到的資料:', data);
    console.log('請求狀態:', textStatus);
    console.log('HTTP 狀態碼:', jqXHR.status);
});

$.ajax('/api/users')
.done(function(data) {
    // data: 伺服器回傳的資料，jQuery 已自動根據 dataType 解析    
    console.log('收到的資料:', data);
});
```

**fail() 方法的錯誤資訊參數：**

```javascript
$.ajax('/api/users')
.fail(function(jqXHR, textStatus, errorThrown) {
    // jqXHR: 包含詳細錯誤資訊的 XMLHttpRequest 物件
    // textStatus: 錯誤類型，如 "error", "timeout", "abort", "parsererror"
    // errorThrown: HTTP 錯誤訊息，如 "Not Found", "Internal Server Error"
    
    console.log('HTTP 狀態:', jqXHR.status);
    console.log('錯誤類型:', textStatus);
    console.log('錯誤訊息:', errorThrown);
    console.log('回應內容:', jqXHR.responseText);
});

$.ajax('/api/users')
.fail(function(jqXHR) {
    // jqXHR: 包含詳細錯誤資訊的 XMLHttpRequest 物件
    console.log('HTTP 狀態:', jqXHR.status);  
});
```

### Promise 方法的簡化參數結構

**then() 方法通常只接收一個參數：**

```javascript
fetch('/api/users')
.then(function(response) {
    // 🔥 fetch() 回傳 Promise<Response>
    // response: Response 物件（需要進一步解析）
    
    if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    return response.json();
    // 取得回應內容：從 Response 物件中讀取 HTTP 回應的 body 內容
    // 解析 JSON：將回應內容（通常是 JSON 字串）解析成 JavaScript 物件
    // 回傳 Promise：這是一個非同步操作，所以回傳 Promise
})
.then(function(data) {
    // data: 解析後的 JSON 資料
    console.log('用戶資料:', data);
});
```

**catch() 方法處理各種錯誤：**

```javascript
Promise.reject(new Error('自定義錯誤'))
.catch(function(error) {
    // error: 可能是 Error 物件、字串或任何被 reject 的值
    console.log('錯誤訊息:', error.message || error);
});
```

## 第三章：資料傳遞機制的根本差異

### jQuery 傳統方法的觀察者模式特性

🔥 **重要發現：done()、fail()、always() 的 return 值都完全無效**

經過深入測試驗證，我們確認了 jQuery 傳統方法的一個重要特性：它們都採用純粹的觀察者模式，任何 return 值都會被完全忽略。

#### done() 方法的觀察者模式

🔥**多個 done() 方法都接收相同的原始資料，不會形成資料傳遞鏈**

javascript

```javascript
$.ajax('/api/users')
.done(function(users) {
	// 🔥users = data from { data, textStatus, jqXHR }
    console.log('第一個 done 接收:', users[0].name); // 原始資料
    
    // 處理資料並回傳
    var processedUsers = users.map(function(user) {
        return {
            id: user.id,
            displayName: user.firstName + ' ' + user.lastName,
            isActive: user.status === 'active'
        };
    });
    
    return processedUsers; // ❌ 這個回傳值完全無用！
})
.done(function(users) {
	// users = data from { data, textStatus, jqXHR }
    console.log('第二個 done 接收:', users[0].name); // 仍然是原始資料
    // 這裡接收到的不是上一個 done() 的 processedUsers
    // 而是同樣的原始 AJAX 回應資料
});
```

#### fail() 方法的同樣特性

🔥**重要發現：fail() 的 return 值和 done() 一樣，完全沒有任何作用**

javascript

```javascript
$.ajax('/nonexistent-endpoint') // 產生 404 錯誤
.fail(function(jqXHR, textStatus, errorThrown) {
    console.log('第一個 fail 處理錯誤:', textStatus); // "error"
    
    // 嘗試提供恢復資料
    var recoveryData = {
        recovered: true,
        message: '嘗試從錯誤中恢復',
        defaultUsers: []
    };
    
    return recoveryData; // ❌ 這個回傳值完全無用！也不會丟出 $.ajax() 外
})
.fail(function(jqXHR, textStatus, errorThrown) {
    console.log('第二個 fail 接收:', textStatus); // 仍然是 "error"
    // 這裡不會接收到上一個 fail() 的 recoveryData
    // 而是同樣的原始錯誤資訊
})
.catch(function(error) {
    // 原始錯誤，不是 fail() 的回傳值
    // 🔥error = jqXHR from {jqXHR, textStatus, errorThrown}
    // fail() 的 return 值對 catch() 也沒有任何影響
    console.log('catch 接收到:', error);     
})
.then(function(result) {
    
    // 情況1：
    // 若 $.ajax() 成功，result 會接收到成功的回傳結果 data from {data, textStatus, jqXHR}
	
	// 情況2：
	// 若 $.ajax() 錯誤，then 接收到 catch 的隱含 return Promise.resolve(undefined);
	
    console.log(result); // fail() 無法改變 Promise 狀態
});
```

#### always() 方法的一致性

javascript

```javascript
$.ajax('/api/data')
.always(function() {
    console.log('清理工作完成');
    
    var cleanupResult = {
        cleaned: true,
        timestamp: Date.now()
    };
    
    return cleanupResult; // ❌ 這個回傳值也完全無用！
})
.then(function(result) {
    // 如果原始請求成功，這裡接收的是原始 AJAX 資料 (result = data from { data, textStatus, jqXHR })
    // 🔥 如果原始請求失敗，then() 不會執行 (會執行 fail、catch、always)
    // 不是 always() 的回傳值
    console.log(result)
});
```

### then() 方法的鏈式傳遞模式

**then() 方法形成真正的資料處理管道**

```javascript
$.ajax('https://jsonplaceholder.typicode.com/users')
.then(function(users) {
    console.log('第一個 then 接收:', users[0].name); // 原始資料
    
    // 根據實際資料結構處理
    var processedUsers = users.map(function(user) {
        return {
            id: user.id,
            displayName: user.name,              // ✅ 直接使用 name
            email: user.email,
            isActive: user.id % 2 === 1          // ✅ 模擬活躍狀態（奇數ID為活躍）
        };
    });
    
    return processedUsers; // 這個回傳值會傳遞給下一個 then()
})
.then(function(processedUsers) {
    console.log('第二個 then 接收:', processedUsers[0].displayName); // 處理後的資料
    // 這裡接收到的是上一個 then() 回傳的 processedUsers
    
    // 繼續處理，例如過濾活躍用戶
    return processedUsers.filter(function(user) {
        return user.isActive;
    });
})
.then(function(activeUsers) {
    console.log('第三個 then 接收活躍用戶數量:', activeUsers.length);
    // 這裡接收到的是過濾後的活躍用戶陣列
});
```

### Promise 自動解析機制的重要性

then() 方法還有一個重要特性：它會自動解析 Promise 物件。這意味著如果你在 then() 中回傳一個 Promise，下一個 then() 會等待該 Promise 解析完成後再接收解析的值：

```javascript
$.ajax('https://jsonplaceholder.typicode.com/users')
.then(function(users) {
    // 假設我們需要根據用戶 ID 獲取額外資訊
    var firstUserId = users[0].id;
    // 獲取該用戶的文章
	// posts 是 jqXHR 物件
	var posts = $.ajax('https://jsonplaceholder.typicode.com/users/' + firstUserId + '/posts');		
	return posts;	// Promise.resolve(jqXHR);
})
// 當 Promise 鏈收到一個 thenable 物件時，它會自動呼叫該物件的 .then() 方法
// jqXHR 也是 thenable 物件，又在 .then () 一次，故 userPosts 是實際資料
.then(function(userPosts) {
    console.log('用戶的文章:', userPosts);
    console.log('文章數量:', userPosts.length);
});
```

## 第四章：錯誤處理機制的關鍵差異

### fail() 方法無法改變 Promise 狀態

**這是 jQuery Deferred 最重要的特性之一：fail() 的回傳值不會影響 Promise 鏈的狀態**

```javascript
$.ajax('/nonexistent-endpoint') // 假設這會產生 404 錯誤
.fail(function(jqXHR, textStatus, errorThrown) {
    console.log('fail 方法執行，處理錯誤');
    console.log('HTTP 狀態:', jqXHR.status); // 404
    console.log('錯誤類型:', textStatus); // "error"
    
    // 嘗試提供預設資料
    var defaultData = {
        message: '使用預設資料',
        users: [],
        isDefault: true
    };

	// 這個回傳值無法改變 Promise 的 rejected 狀態！
	// 🔥 不會傳給後面的鏈式，也不會傳到 $.ajax 外面，幾乎沒用
    return defaultData;
})
.then(function(data) {
    console.log('這個 then 不會執行'); // 因為 ajax 發生錯誤，只會調用 fail、catch
    // 若 ajax 正常，則會執行， data = data from { data, textStatus, jqXHR }
})
.catch(function(error) {
    // error = jqXHR from { jqXHR, textStatus, errorThrown}
    console.log('catch 仍然會執行'); // 會執行，接收原始的 AJAX 錯誤
    // 這裡不會接收到 fail() 回傳的 defaultData
});
```

### catch() 方法可以恢復 Promise 狀態

**catch() 方法可以透過回傳值將 rejected Promise 轉換為 resolved Promise**

```javascript
$.ajax('/nonexistent-endpoint')
.catch(function(error) {
    console.log('catch 方法處理錯誤:', error);
    
    // 提供預設資料並恢復 Promise 狀態
    var recoveryData = {
        message: '已恢復，使用預設資料',
        users: [
            { id: 1, name: '預設用戶', status: 'active' }
        ],
        isRecovered: true
    };
    
    return recoveryData; // 這會將 Promise 轉換為 resolved 狀態
})
.then(function(data) {
    console.log('這個 then 會執行:', data.message); // 會執行並接收 recoveryData
    console.log('資料已恢復:', data.isRecovered); // true
});
```

### then() 錯誤回調的特殊用法

如果你想在 jQuery 環境中實現類似 catch() 的恢復功能，可以使用 then() 方法的第二個參數：

```javascript
$.ajax('/nonexistent-endpoint')
.then(
	🔥 // 同時處理 ajax 成功跟失敗的情況，處理完成後，再丟給下一個 then
    function(data) {
        // 成功回調
        console.log('請求成功:', data);
        return data;
    },
    function(jqXHR, textStatus, errorThrown) {
        // 錯誤回調 - 這裡的回傳值可以恢復 Promise 狀態
        console.log('錯誤處理:', textStatus);
        
        var errorRecoveryData = {
            error: true,
            message: '請求失敗，但已處理',
            fallbackData: []
        };
        
        return errorRecoveryData; // 這會讓 Promise 變成 resolved 狀態
    }
)
.then(function(result) {
    console.log('後續處理:', result);
    // 這裡會執行，不管原始請求成功還是失敗
    // 如果失敗，result 就是 errorRecoveryData
});
```

## 第五章：return 和 throw 的包裝機制詳解

### jQuery 傳統方法的直接回傳

傳統的 `done()`, `fail()`, `always()` 方法不會自動包裝回傳值。它們的回傳值會被忽略，幾乎沒用 ??

```javascript
$.ajax('/api/data')
.done(function(data) {
    var processedData = {
        original: data,
        processed: true,
        timestamp: Date.now()
    };
    
    return processedData; // 這個回傳值被忽略，不影響後續的 done()
})
.done(function(data) {
    // 這裡仍然接收原始的 AJAX 資料，不是上面的 processedData
    console.log('仍然是原始資料:', data);
});
```

### jQuery Promise 方法的自動包裝

`then()`, `catch()`, `finally()` 方法會自動將回傳值包裝成 Promise：

```javascript
$.ajax('/api/data')
.then(function(data) {
    var transformedData = data.items.map(function(item) {
        return {
            id: item.id,
            title: item.name.toUpperCase(),
            summary: item.description.substring(0, 100)
        };
    });
    
    return transformedData; // 自動包裝成 Promise.resolve(transformedData)
})
// 從上一個 then() 所回傳的 Promise 中，解析資料取得 transformedData，再傳入下一個 then()
.then(function(transformedData) {	
    console.log('接收到轉換後的資料:', transformedData);
    console.log('處理完成');
	// 即使沒有明確的 return 語句
    // 隱式 return undefined，會被包裝成 Promise.resolve(undefined)
})
.then(function(result) {
    console.log('這裡的 result 是:', result); // undefined
});
```

### 錯誤拋出的差異處理

在傳統方法中拋出錯誤和在 Promise 方法中拋出錯誤也有不同的效果：

```javascript
// 在 done() 中拋出錯誤
$.ajax('/api/data')
.done(function(data) {
    if (!data.isValid) {
        throw new Error('資料驗證失敗'); // 這個錯誤可能不會被正確處理
    }
	🔥 // 經測試，這個 return 即不是傳給後面的 done()、fail()、catch()，也不是回傳到整個鏈式結果，幾乎沒有用處
    return data;
})
.fail(function(jqXHR, textStatus, errorThrown) {
    console.log('fail 不會捕獲 done() 中的錯誤'); // 通常不會執行
})
.catch(function(error) {
    console.log('catch 也不會捕獲 done() 中的錯誤:', error.message); // 會執行
});

// 在 then() 中拋出錯誤
$.ajax('/api/data')
.then(function(data) {
    if (!data.isValid) {
        throw new Error('資料驗證失敗'); // 這個錯誤會被正確處理
    }
    return data;

	🔥 // 複習一下，在 Promise 以下情況，會觸發 catch
	// throw new Error('資料驗證失敗')
	// Promise.reject(new Error('資料驗證失敗'))
})
.catch(function(error) {
    console.log('catch 捕獲錯誤:', error.message); // 會執行
    return { isValid: true, data: [], isDefault: true }; // 可以恢復
})
.then(function(recoveredData) {
    console.log('使用恢復的資料:', recoveredData); // 會執行
});
```

## 第六章：AJAX 錯誤執行流程的完整分析

### 錯誤同時觸發多個處理器

當 AJAX 請求失敗時，jQuery Deferred 會同時觸發所有相關的錯誤處理方法：

```javascript
$.ajax('/nonexistent-endpoint')
.done(function(data) {
    console.log('done: 因為請求失敗，這裡不會執行');
})
.fail(function(jqXHR, textStatus, errorThrown) {
    console.log('1. fail 執行 - 提供詳細錯誤資訊');
    console.log('   狀態碼:', jqXHR.status);
    console.log('   錯誤類型:', textStatus);
    console.log('   錯誤訊息:', errorThrown);
    
    // 即使這裡不拋出錯誤，後面的 catch 仍然會執行
    // 因為原始的 AJAX 錯誤會繼續傳播
})
.catch(function(error) {
    console.log('2. catch 執行 - 統一錯誤處理');
    console.log('   捕獲到的錯誤:', error);
    
    // 只有在這裡回傳值，才能改變後續的執行流程
    return { handled: true, message: '錯誤已處理' };
})
.then(function(result) {
    console.log('3. then 執行 - 接收 catch 的回傳值:', result);
})
.always(function() {
    console.log('4. always 總是執行 - 清理工作');
});
```

### 複雜錯誤處理策略

在實際應用中，你可能需要結合使用不同的錯誤處理方法來實現完整的錯誤處理策略：

```javascript
function handleUserRequest(userId) {
    return $.ajax('/api/users/' + userId)
    .fail(function(jqXHR, textStatus, errorThrown) {
        // 詳細記錄 AJAX 層級的錯誤資訊
        logError('AJAX_ERROR', {
            url: '/api/users/' + userId,
            status: jqXHR.status,
            statusText: jqXHR.statusText,
            textStatus: textStatus,
            errorThrown: errorThrown,
            responseText: jqXHR.responseText
        });
        
        // fail() 不嘗試恢復，只負責記錄
    })
    .catch(function(error) {
        // 根據錯誤類型提供不同的恢復策略
        console.log('執行錯誤恢復策略');
        
        if (error.status === 404) {
            // 用戶不存在，回傳預設用戶資訊
            return {
                id: userId,
                name: '未知用戶',
                status: 'inactive',
                isDefault: true
            };
        } else if (error.status >= 500) {
            // 伺服器錯誤，拋出新的錯誤讓上層處理
            throw new Error('伺服器暫時無法處理請求，請稍後再試');
        } else {
            // 其他錯誤，回傳空用戶資訊
            return {
                id: null,
                name: '載入失敗',
                status: 'error',
                isDefault: true
            };
        }
    })
    .then(function(userData) {
        // 統一處理最終的用戶資料（無論是成功取得還是錯誤恢復的）
        if (userData.isDefault) {
            console.log('使用預設或恢復的用戶資料');
        }
        
        return {
            user: userData,
            timestamp: Date.now(),
            source: userData.isDefault ? 'fallback' : 'api'
        };
    });
}
```

## 第七章：版本差異與實務應用策略

### Portal 系統（jQuery 3.3.1）的現代化開發策略

在較新的 jQuery 版本中，我們可以充分利用 Promise 的優勢來構建更清晰的異步程式碼：

```javascript
// 推薦的現代化錯誤處理模式
function loadDashboardData() {
    // 使用 Promise.all 並行載入多個資料源
    var userDataPromise = $.ajax('/api/current-user')
    .catch(function(error) {
        console.warn('用戶資料載入失敗，使用訪客模式');
        return { isGuest: true, name: '訪客' };
    });
    
    var statisticsPromise = $.ajax('/api/statistics')
    .catch(function(error) {
        console.warn('統計資料載入失敗，使用預設值');
        return { visits: 0, sales: 0, isDefault: true };
    });
    
    var notificationsPromise = $.ajax('/api/notifications')
    .catch(function(error) {
        console.warn('通知載入失敗');
        return [];
    });
    
    return Promise.all([userDataPromise, statisticsPromise, notificationsPromise])
    .then(function(results) {
        var userData = results[0];
        var statistics = results[1];
        var notifications = results[2];
        
        return {
            user: userData,
            stats: statistics,
            notifications: notifications,
            loadTime: Date.now()
        };
    })
    .catch(function(error) {
        // 如果所有請求都失敗，提供最基本的預設資料
        console.error('儀表板資料載入完全失敗:', error);
        return {
            user: { isGuest: true, name: '訪客' },
            stats: { visits: 0, sales: 0, isDefault: true },
            notifications: [],
            error: true,
            message: '部分資料載入失敗'
        };
    });
}

// 使用方式
loadDashboardData()
.then(function(dashboardData) {
    renderDashboard(dashboardData);
    
    if (dashboardData.error) {
        showWarningMessage('部分資料無法載入，顯示可用資料');
    }
})
.catch(function(error) {
    showErrorPage('儀表板無法載入，請重新整理頁面');
});
```

### GTS 系統（jQuery 1.10.2）的穩定開發策略

在較舊的 jQuery 版本中，建議主要使用傳統但穩定的 Deferred 方法：

```javascript
// 適合舊版本的穩定錯誤處理模式
function loadUserProfile(userId) {
    var loadingIndicator = showLoading('載入用戶資料中...');
    
    $.ajax({
        url: '/api/users/' + userId,
        type: 'GET',
        timeout: 15000,
        cache: false,
        dataType: 'json'
    })
    .done(function(userData, textStatus, jqXHR) {
        // 成功載入用戶資料
        console.log('用戶資料載入成功:', userData.name);
        
        // 驗證資料完整性
        if (!userData.id || !userData.name) {
            handleIncompleteData(userData);
            return;
        }
        
        // 渲染用戶介面
        renderUserProfile(userData);
        updateUserMenu(userData);
        logUserActivity('profile_viewed', userData.id);
    })
    .fail(function(jqXHR, textStatus, errorThrown) {
        // 詳細的錯誤處理
        console.error('用戶資料載入失敗:', {
            status: jqXHR.status,
            statusText: jqXHR.statusText,
            textStatus: textStatus,
            errorThrown: errorThrown
        });
        
        var errorMessage;
        var shouldRetry = false;
        
        switch (jqXHR.status) {
            case 401:
                errorMessage = '登入已過期，請重新登入';
                redirectToLogin();
                break;
            case 403:
                errorMessage = '權限不足，無法查看此用戶資料';
                break;
            case 404:
                errorMessage = '找不到指定的用戶';
                break;
            case 408:
            case 504:
                errorMessage = '請求逾時，請檢查網路連線';
                shouldRetry = true;
                break;
            case 500:
            case 502:
            case 503:
                errorMessage = '伺服器暫時無法處理請求';
                shouldRetry = true;
                break;
            default:
                if (textStatus === 'timeout') {
                    errorMessage = '連線逾時，請稍後再試';
                    shouldRetry = true;
                } else if (textStatus === 'abort') {
                    errorMessage = '請求被中止';
                } else {
                    errorMessage = '載入失敗：' + (errorThrown || '未知錯誤');
                }
        }
        
        showErrorMessage(errorMessage);
        
        if (shouldRetry) {
            showRetryButton(function() {
                loadUserProfile(userId);
            });
        }
        
        // 載入預設的訪客資料
        renderGuestProfile();
    })
    .always(function() {
        // 清理工作
        hideLoading(loadingIndicator);
        enableUserInterface();
    });
}
```

## 第八章：實務開發的最佳實踐與模式

### 建立統一的 AJAX 封裝層

為了在不同專案中保持一致性，建議建立一個統一的 AJAX 封裝函數：

```javascript
// 為 Portal 系統設計的現代化封裝
function createApiClient() {
    var baseConfig = {
        timeout: 30000,
        cache: false,
        headers: {
            'X-Requested-With': 'XMLHttpRequest'
        }
    };
    
    function makeRequest(url, options) {
        var config = $.extend({}, baseConfig, { url: url }, options);
        
        return $.ajax(config)
        .then(function(data, textStatus, jqXHR) {
            // 統一的成功回應處理
            if (data && data.status === 'error') {
                // 業務層級的錯誤
                throw new Error(data.message || '業務處理失敗');
            }
            
            return {
                data: data,
                status: jqXHR.status,
                headers: parseHeaders(jqXHR.getAllResponseHeaders()),
                timestamp: Date.now()
            };
        })
        .catch(function(error) {
            // 統一的錯誤處理和轉換
            var standardError = {
                message: '請求失敗',
                type: 'network_error',
                status: error.status || 0,
                timestamp: Date.now(),
                originalError: error
            };
            
            if (error.status) {
                switch (error.status) {
                    case 401:
                        standardError.type = 'auth_error';
                        standardError.message = '需要重新登入';
                        break;
                    case 403:
                        standardError.type = 'permission_error';
                        standardError.message = '權限不足';
                        break;
                    case 429:
                        standardError.type = 'rate_limit_error';
                        standardError.message = '請求過於頻繁';
                        break;
                    case 500:
                        standardError.type = 'server_error';
                        standardError.message = '伺服器錯誤';
                        break;
                }
            }
            
            // 記錄錯誤
            logApiError(url, standardError);
            
            throw standardError;
        });
    }
    
    return {
        get: function(url, params) {
            return makeRequest(url, { type: 'GET', data: params });
        },
        post: function(url, data) {
            return makeRequest(url, { 
                type: 'POST', 
                data: JSON.stringify(data),
                contentType: 'application/json'
            });
        },
        put: function(url, data) {
            return makeRequest(url, { 
                type: 'PUT', 
                data: JSON.stringify(data),
                contentType: 'application/json'
            });
        },
        delete: function(url) {
            return makeRequest(url, { type: 'DELETE' });
        }
    };
}

// 使用範例
var apiClient = createApiClient();

apiClient.get('/api/users', { page: 1, limit: 10 })
.then(function(response) {
    console.log('成功載入用戶列表:', response.data);
    renderUserList(response.data.users);
})
.catch(function(error) {
    console.error('載入用戶列表失敗:', error);
    
    switch (error.type) {
        case 'auth_error':
            redirectToLogin();
            break;
        case 'permission_error':
            showPermissionError();
            break;
        default:
            showGenericError('無法載入用戶列表，請稍後再試');
    }
});
```

### 錯誤恢復和降級策略

在企業級應用中，優雅的錯誤處理和服務降級是非常重要的：

```javascript
// 多層級的錯誤恢復策略
function loadCriticalData() {
    return loadFromPrimaryAPI()
    .catch(function(primaryError) {
        console.warn('主要 API 失敗，嘗試備用 API:', primaryError.message);
        return loadFromBackupAPI();
    })
    .catch(function(backupError) {
        console.warn('備用 API 也失敗，使用本地快取:', backupError.message);
        return loadFromLocalCache();
    })
    .catch(function(cacheError) {
        console.warn('本地快取也失敗，使用預設資料:', cacheError.message);
        return getDefaultData();
    })
    .then(function(data) {
        // 標記資料來源，讓 UI 可以適當地顯示狀態
        if (data.source === 'default') {
            showDataSourceWarning('使用預設資料，部分功能可能受限');
        } else if (data.source === 'cache') {
            showDataSourceInfo('使用快取資料，可能不是最新資訊');
        }
        
        return data;
    });
}

function loadFromPrimaryAPI() {
    return $.ajax('/api/v2/data')
    .then(function(response) {
        return { ...response, source: 'primary' };
    });
}

function loadFromBackupAPI() {
    return $.ajax('/api/v1/data')
    .then(function(response) {
        return { ...response, source: 'backup' };
    });
}

function loadFromLocalCache() {
    var cachedData = localStorage.getItem('criticalData');
    if (cachedData) {
        try {
            var parsed = JSON.parse(cachedData);
            return Promise.resolve({ ...parsed, source: 'cache' });
        } catch (e) {
            return Promise.reject(new Error('快取資料損壞'));
        }
    }
    return Promise.reject(new Error('無快取資料'));
}

function getDefaultData() {
    return Promise.resolve({
        items: [],
        total: 0,
        message: '無可用資料',
        source: 'default'
    });
}
```

### 進階錯誤處理模式

實際應用中，我們還需要考慮重試機制、斷路器模式等進階策略：

```javascript
// 實作重試機制的 AJAX 封裝
function ajaxWithRetry(options, maxRetries = 3, retryDelay = 1000) {
    var attempt = 0;
    
    function makeAttempt() {
        attempt++;
        
        return $.ajax(options)
        .catch(function(error) {
            console.log(`請求失敗，嘗試 ${attempt}/${maxRetries + 1}:`, error.status);
            
            // 判斷是否應該重試
            var shouldRetry = attempt <= maxRetries && 
                             (error.status >= 500 || 
                              error.status === 0 || 
                              error.status === 408 ||
                              error.status === 429);
            
            if (shouldRetry) {
                // 指數退避策略
                var delay = retryDelay * Math.pow(2, attempt - 1);
                console.log(`${delay}ms 後重試...`);
                
                return new Promise(function(resolve) {
                    setTimeout(resolve, delay);
                }).then(makeAttempt);
            } else {
                // 不再重試，拋出最終錯誤
                throw error;
            }
        });
    }
    
    return makeAttempt();
}

// 使用重試機制
ajaxWithRetry({
    url: '/api/important-data',
    type: 'GET',
    timeout: 5000
}, 3, 1000)
.then(function(data) {
    console.log('資料載入成功:', data);
})
.catch(function(error) {
    console.error('多次重試後仍然失敗:', error);
    showCriticalError('系統暫時無法存取，請聯絡技術支援');
});
```

### 批次請求的錯誤處理

在需要載入多個相關資料的情況下，適當的錯誤處理策略很重要：

```javascript
// 部分成功的批次載入策略
function loadUserDashboard(userId) {
    var requests = {
        profile: $.ajax('/api/users/' + userId),
        permissions: $.ajax('/api/users/' + userId + '/permissions'),
        preferences: $.ajax('/api/users/' + userId + '/preferences'),
        notifications: $.ajax('/api/users/' + userId + '/notifications'),
        analytics: $.ajax('/api/users/' + userId + '/analytics')
    };
    
    // 為每個請求添加錯誤恢復
    var safeRequests = {};
    Object.keys(requests).forEach(function(key) {
        safeRequests[key] = requests[key].catch(function(error) {
            console.warn(`${key} 載入失敗:`, error.status);
            
            // 為不同類型的資料提供不同的預設值
            switch (key) {
                case 'profile':
                    return { name: '未知用戶', status: 'inactive' };
                case 'permissions':
                    return { canEdit: false, canDelete: false, canView: true };
                case 'preferences':
                    return { theme: 'light', language: 'zh-TW' };
                case 'notifications':
                    return [];
                case 'analytics':
                    return { views: 0, clicks: 0, conversions: 0 };
                default:
                    return null;
            }
        });
    });
    
    // 等待所有請求完成（包括失敗後的恢復）
    return Promise.all([
        safeRequests.profile,
        safeRequests.permissions,
        safeRequests.preferences,
        safeRequests.notifications,
        safeRequests.analytics
    ])
    .then(function(results) {
        return {
            profile: results[0],
            permissions: results[1],
            preferences: results[2],
            notifications: results[3],
            analytics: results[4],
            loadTime: Date.now(),
            hasPartialFailures: Object.keys(requests).some(function(key, index) {
                return results[index] && results[index].constructor === Object && 
                       Object.keys(results[index]).length < 3; // 簡單檢查是否為預設值
            })
        };
    });
}
```

## 第九章：除錯與測試策略

### 開發階段的錯誤追蹤

在開發過程中，建立完整的錯誤追蹤機制有助於快速定位問題：

```javascript
// 開發環境的詳細錯誤記錄
function setupAjaxDebugging() {
    // 攔截所有 AJAX 請求
    $(document).ajaxSend(function(event, jqXHR, settings) {
        console.group(`🚀 AJAX 請求: ${settings.type} ${settings.url}`);
        console.log('設定:', settings);
        console.log('Headers:', jqXHR.getAllResponseHeaders());
        console.time('請求時間');
    });
    
    $(document).ajaxComplete(function(event, jqXHR, settings) {
        console.timeEnd('請求時間');
        console.log(`📥 回應狀態: ${jqXHR.status} ${jqXHR.statusText}`);
        console.groupEnd();
    });
    
    $(document).ajaxError(function(event, jqXHR, settings, errorThrown) {
        console.group(`❌ AJAX 錯誤: ${settings.type} ${settings.url}`);
        console.error('狀態:', jqXHR.status);
        console.error('錯誤:', errorThrown);
        console.error('回應:', jqXHR.responseText);
        console.groupEnd();
    });
}

// 在開發環境中啟用
if (window.location.hostname === 'localhost' || window.location.hostname.includes('dev')) {
    setupAjaxDebugging();
}
```

### 單元測試的錯誤處理驗證

```javascript
// 使用 QUnit 測試錯誤處理行為
QUnit.module('AJAX 錯誤處理測試');

QUnit.test('done() 方法不會傳遞回傳值', function(assert) {
    var done = assert.async(2);
    var firstDoneData, secondDoneData;
    
    // 模擬成功的 AJAX 回應
    var mockData = { id: 1, name: 'Test User' };
    var deferred = $.Deferred();
    
    deferred.promise()
    .done(function(data) {
        firstDoneData = data;
        assert.deepEqual(data, mockData, '第一個 done 接收原始資料');
        done();
        
        return { processed: true, name: data.name.toUpperCase() };
    })
    .done(function(data) {
        secondDoneData = data;
        assert.deepEqual(data, mockData, '第二個 done 仍接收原始資料');
        assert.notOk(data.processed, '第二個 done 沒有接收到第一個 done 的回傳值');
        done();
    });
    
    deferred.resolve(mockData);
});

QUnit.test('fail() 方法無法恢復 Promise 狀態', function(assert) {
    var done = assert.async(2);
    var failExecuted = false;
    var thenExecuted = false;
    
    var deferred = $.Deferred();
    
    deferred.promise()
    .fail(function(error) {
        failExecuted = true;
        assert.ok(true, 'fail 方法執行');
        done();
        
        return { recovered: true, data: 'default' };
    })
    .then(function(data) {
        thenExecuted = true;
        assert.ok(false, 'then 不應該執行');
    })
    .catch(function(error) {
        assert.ok(failExecuted, 'fail 已執行');
        assert.notOk(thenExecuted, 'then 沒有執行');
        assert.equal(error, 'test error', 'catch 接收原始錯誤');
        done();
    });
    
    deferred.reject('test error');
});
```

## 總結與核心重點

經過深入的討論、測試和驗證，我們得出了以下核心結論：

### 最重要的發現

**第一個核心發現**：jQuery 的 `done()` 方法採用觀察者模式，多個 `done()` 都接收相同的原始 AJAX 資料，不會形成資料傳遞鏈。這與我們最初的理解完全不同。

**第二個核心發現**：`fail()` 方法無法透過回傳值改變 Promise 鏈的狀態。即使 `fail()` 回傳了資料，後續的 `then()` 仍然不會執行，`catch()` 仍然會接收原始錯誤。

**第三個核心發現**：只有 `then()`, `catch()`, `finally()` 這些 Promise 方法才能形成真正的鏈式傳遞和狀態轉換。

### 實務應用指南

在華碩的兩個系統開發中：

**Portal 系統（jQuery 3.3.1）** 建議採用現代 Promise 模式：

- 使用 `then()/catch()` 進行資料轉換和錯誤恢復
- 建立統一的 API 客戶端封裝
- 實作重試機制和降級策略
- 充分利用 Promise.all 和 async/await 語法

**GTS 系統（jQuery 1.10.2）** 建議保持傳統模式的穩定性：

- 主要使用 `done()/fail()/always()`
- `fail()` 專注於錯誤記錄和分析
- 避免混用傳統方法和 Promise 方法
- 建立清晰的錯誤分類和處理流程

### 關鍵提醒

1. **永遠記住**：`done()` 不會傳遞資料，每個 `done()` 都接收原始資料
2. **永遠記住**：`fail()` 不能恢復錯誤狀態，要用 `catch()` 或 `then()` 的錯誤回調
3. **保持一致性**：在同一個專案中避免混用不同的錯誤處理模式
4. **測試驗證**：任何關於 jQuery 行為的假設都應該透過實際測試來驗證

這些理解將幫助我們在日常開發中做出更準確的技術決策，避免常見的陷阱，並建立更穩健的錯誤處理機制。