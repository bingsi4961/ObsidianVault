---
date : 2025-07-07 22:15
aliases:
  - 別名測試1
  - 別名測試2
tags:
  - 標籤測試1
  - 標籤測試2

---
# Metadata
Status :: 🌱
Note Type :: 📰
Source URL :: {文章 URL}
Author :: {作者名稱}
Topics :: {筆記跟什麼主題有關，用 `[Topic],[Topic]` 格式}

---
# 連結筆記
##### 📑 [[歡迎]]
##### 📑 [[歡迎]]

---

## 從你熟悉的 C# 開始理解

在 C# 中，你可能已經寫過這樣的程式碼：

```csharp
public async Task<string> GetUserDataAsync(int userId)
{
    var response = await httpClient.GetAsync($"/api/users/{userId}");
    var content = await response.Content.ReadAsStringAsync();
    return content;
}
```

JavaScript 的 async/await 概念幾乎一模一樣，只是語法稍有不同。這種相似性會讓你的學習過程更加順暢。

## 理解 async/await 的核心概念

async/await 實際上是 Promise 的一種更優雅的寫法。當你在函式前面加上 `async` 關鍵字，這個函式就會自動回傳一個 Promise。而 `await` 關鍵字則讓你可以「等待」一個 Promise 完成，就像暫停程式執行直到結果出現。

讓我們先看一個簡單的對比，幫助你理解兩者之間的關係：

```javascript
// 使用傳統 Promise 的寫法
function fetchUserDataWithPromise(userId) {
    return fetch(`/api/users/${userId}`)
        .then(response => response.json())
        .then(userData => {
            console.log("取得使用者資料：", userData);
            return userData;
        })
        .catch(error => {
            console.error("發生錯誤：", error);
            throw error;
        });
}

// 使用 async/await 的寫法 - 是不是看起來更清楚？
async function fetchUserDataWithAsync(userId) {
    try {
        const response = await fetch(`/api/users/${userId}`);
        const userData = await response.json();
        console.log("取得使用者資料：", userData);
        return userData;
    } catch (error) {
        console.error("發生錯誤：", error);
        throw error;
    }
}
```

你注意到了嗎？async/await 版本讀起來就像是一般的同步程式碼，但實際上它仍然是異步執行的。這種可讀性的提升是 async/await 最大的優勢。

## async 函式的特性

當你在函式前面加上 `async` 關鍵字時，這個函式會有幾個重要的特性：

首先，它總是回傳一個 Promise。即使你在函式中直接回傳一個值，JavaScript 也會自動將它包裝成一個 resolved 的 Promise。

```javascript
// 這個函式會回傳 Promise<string>
async function greetUser() {
    return "你好！"; // 自動包裝成 Promise.resolve("你好！")
}

// 所以你可以這樣使用它
greetUser().then(message => console.log(message)); // 輸出：你好！
```

其次，只有在 async 函式內部才能使用 `await` 關鍵字。這是一個重要的規則，記住它會幫助你避免很多錯誤。

## await 的運作原理

`await` 關鍵字的作用是暫停函式的執行，直到 Promise 解析完成。重要的是要理解，這種「暫停」不會阻塞整個程式，只是暫停當前的函式執行流程。

```javascript
async function demonstrateAwait() {
    console.log("開始執行");
    
    // 這裡會暫停，等待 Promise 完成
    const result = await new Promise(resolve => {
        setTimeout(() => resolve("延遲的結果"), 2000);
    });
    
    console.log("取得結果：", result);
    console.log("函式執行完成");
}

// 呼叫函式
demonstrateAwait();
console.log("這行會立即執行，不會等待上面的函式完成");
```

這個範例會輸出：

```
開始執行
這行會立即執行，不會等待上面的函式完成
（等待 2 秒）
取得結果：延遲的結果
函式執行完成
```

## 在你的工作環境中應用 async/await

讓我們看看如何在你的 Portal 系統（使用 jQuery 3.3.1）中應用這些概念。jQuery 本身並不直接支援 Promise，但我們可以輕鬆地將 jQuery AJAX 轉換為 Promise：

```javascript
// 建立一個輔助函式，將 jQuery AJAX 轉換為 Promise
function ajaxPromise(options) {
    return new Promise((resolve, reject) => {
        $.ajax(options)
            .done(resolve)  // 成功時解析 Promise
            .fail(reject);  // 失敗時拒絕 Promise
    });
}

// 現在你可以在 Portal 系統中使用 async/await
async function loadUserProfile(userId) {
    try {
        // 載入基本使用者資料
        const userData = await ajaxPromise({
            url: `/api/users/${userId}`,
            method: 'GET',
            dataType: 'json'
        });
        
        // 根據使用者資料載入部門資訊
        const departmentData = await ajaxPromise({
            url: `/api/departments/${userData.departmentId}`,
            method: 'GET',
            dataType: 'json'
        });
        
        // 更新頁面顯示
        $('#userName').text(userData.name);
        $('#userEmail').text(userData.email);
        $('#userDepartment').text(departmentData.name);
        
        console.log("使用者資料載入完成");
        return { user: userData, department: departmentData };
        
    } catch (error) {
        console.error("載入使用者資料時發生錯誤：", error);
        $('#errorMessage').text('載入使用者資料失敗，請稍後再試').show();
        throw error; // 重新拋出錯誤讓呼叫者處理
    }
}
```

你是否注意到這個程式碼的流程多麼清晰？我們先載入使用者資料，然後根據使用者的部門ID載入部門資訊，最後更新頁面。每一步都會等待前一步完成，但整個過程仍然是異步的。

## 錯誤處理：try/catch 的威力

async/await 的另一個巨大優勢是錯誤處理變得更加直觀。與其使用 `.catch()`，你可以使用熟悉的 `try/catch` 區塊：

```javascript
async function robustApiCall(endpoint, data) {
    try {
        // 第一步：驗證參數
        if (!endpoint) {
            throw new Error("API 端點不能為空");
        }
        
        // 第二步：發送請求
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${getAuthToken()}`
            },
            body: JSON.stringify(data)
        });
        
        // 第三步：檢查 HTTP 狀態
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        // 第四步：解析回應
        const result = await response.json();
        
        // 第五步：驗證回應格式
        if (!result.success) {
            throw new Error(result.message || "API 回應指示操作失敗");
        }
        
        return result.data;
        
    } catch (error) {
        // 所有步驟中的任何錯誤都會在這裡被捕獲
        console.error("API 呼叫失敗：", error.message);
        
        // 你可以根據不同的錯誤類型做不同的處理
        if (error.message.includes("HTTP 401")) {
            // 認證失敗，可能需要重新登入
            redirectToLogin();
        } else if (error.message.includes("HTTP 500")) {
            // 伺服器錯誤
            showServerErrorMessage();
        }
        
        throw error; // 重新拋出讓上層處理
    }
}
```

## 並行處理：當你不需要等待時

有時候你有多個獨立的異步操作，不需要按順序執行。這時候你可以結合 `Promise.all` 和 async/await：

```javascript
async function loadDashboardData(userId) {
    try {
        // 這些資料可以同時載入，因為它們互不依賴
        const [userData, notifications, statistics, recentActivities] = await Promise.all([
            ajaxPromise({ url: `/api/users/${userId}`, method: 'GET' }),
            ajaxPromise({ url: `/api/notifications/${userId}`, method: 'GET' }),
            ajaxPromise({ url: `/api/statistics/${userId}`, method: 'GET' }),
            ajaxPromise({ url: `/api/activities/${userId}`, method: 'GET' })
        ]);
        
        // 當所有資料都載入完成後，更新不同的頁面區域
        updateUserSection(userData);
        updateNotificationSection(notifications);
        updateStatisticsSection(statistics);
        updateActivitiesSection(recentActivities);
        
        console.log("儀表板所有資料載入完成");
        
    } catch (error) {
        console.error("載入儀表板資料失敗：", error);
        showDashboardErrorMessage();
    }
}
```

這種方式比依序等待每個請求完成要快得多，因為所有請求是同時發出的。

## 實用的模式：條件性異步操作

在實際開發中，你經常需要根據某些條件來決定是否執行異步操作：

```javascript
async function smartUserDataLoader(userId, options = {}) {
    try {
        // 先檢查快取
        let userData = getCachedUserData(userId);
        
        if (!userData || options.forceRefresh) {
            console.log("從伺服器載入使用者資料...");
            userData = await ajaxPromise({
                url: `/api/users/${userId}`,
                method: 'GET',
                dataType: 'json'
            });
            
            // 將資料存入快取
            setCachedUserData(userId, userData);
        } else {
            console.log("使用快取的使用者資料");
        }
        
        // 如果需要載入額外的詳細資料
        if (options.includeDetails) {
            const detailsData = await ajaxPromise({
                url: `/api/users/${userId}/details`,
                method: 'GET',
                dataType: 'json'
            });
            
            userData.details = detailsData;
        }
        
        return userData;
        
    } catch (error) {
        console.error("載入使用者資料失敗：", error);
        throw error;
    }
}

// 使用方式
const basicUserData = await smartUserDataLoader(123);
const detailedUserData = await smartUserDataLoader(123, { includeDetails: true });
const freshUserData = await smartUserDataLoader(123, { forceRefresh: true });
```

## 避免常見的陷阱

讓我提醒你一些使用 async/await 時常見的錯誤，這樣你就能避免它們：

第一個常見錯誤是忘記在頂層使用 await。記住，你不能在非 async 函式中直接使用 await：

```javascript
// 錯誤的寫法
function normalFunction() {
    const result = await someAsyncOperation(); // 這會導致語法錯誤
}

// 正確的寫法
async function asyncFunction() {
    const result = await someAsyncOperation(); // 這是正確的
}

// 或者在頂層程式碼中，你需要這樣處理
someAsyncOperation().then(result => {
    console.log(result);
});
```

第二個常見錯誤是在迴圈中錯誤使用 await：

```javascript
// 這會依序執行，可能比你想的要慢
async function slowWay(userIds) {
    const results = [];
    for (const userId of userIds) {
        const userData = await fetchUserData(userId); // 每次都要等待
        results.push(userData);
    }
    return results;
}

// 這會並行執行，通常更快
async function fastWay(userIds) {
    const promises = userIds.map(userId => fetchUserData(userId));
    const results = await Promise.all(promises);
    return results;
}
```

## 與你的開發環境整合

在你的 GTS 系統（使用較舊的 jQuery 1.10.2）中，你可能需要考慮瀏覽器相容性。async/await 在較舊的瀏覽器中可能不被支援，但你可以使用 Babel 等工具來轉換程式碼，或者在支援的環境中逐步採用。

現在我想問你一個思考問題：在你目前的專案中，有沒有哪些地方使用了很多巢狀的回調函式或者複雜的 Promise 鏈？這些地方可能是應用 async/await 的絕佳候選。

你是否想要嘗試將某個現有的功能改寫為使用 async/await？或者你對某個特定的使用情境有疑問？我們可以一起來探討具體的實作方式。