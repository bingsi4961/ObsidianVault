---
date: 2025-07-07 10:48
aliases: 
tags:
  - jQuery
  - AJAX
  - JavaScript
  - Promise
---
# Metadata
Status :: 🌱
Note Type :: 📰
Source URL :: {文章 URL}
Author :: {作者名稱}
Topics :: {筆記跟什麼主題有關，用 `[Topic],[Topic]` 格式}

---

#### 📑 [[HttpResponse]]


## 前言

這份筆記詳細記錄了 `$.ajax().done().fail()` 與 `Promise.then().catch()` 的差異，特別是在錯誤處理機制上的重要區別。

## 第一章：物件型態與基礎概念

### $.ajax() 回傳的物件型態

`$.ajax()` 回傳的是 **jQuery Deferred 物件**，這是 jQuery 特有的 Promise-like 物件。雖然它實作了 Promise/A+ 標準，但並非原生 JavaScript Promise。這個物件提供了 `.done()`, `.fail()`, `.always()` 等傳統方法，也支援 `.then()`, `.catch()`, `.finally()` 等現代 Promise 方法。

理解這個雙重性質很重要，因為傳統方法和現代方法在資料處理上有根本性的差異。傳統方法採用的是「觀察者模式」，而現代方法採用的是「鏈式傳遞模式」。

### Promise 回傳的物件型態

原生 JavaScript Promise 是 ES6 標準的 Promise 物件，提供 `.then()`, `.catch()`, `.finally()` 等方法。這是現代 JavaScript 的標準異步處理方式。
Promise 的設計哲學是純粹的鏈式傳遞，每個 `.then()` 都會回傳一個新的 Promise，形成清晰的資料流向。

## 第二章：方法參數與資料型態

### jQuery 傳統方法的參數結構

**done() 方法的參數：**

```javascript
$.ajax('/api/data')
.done(function(data, textStatus, jqXHR) {
    // data: 伺服器回傳的資料（已解析，如 JSON 物件）
    // textStatus: 字串，如 "success"
    // jqXHR: jQuery XMLHttpRequest 物件
});
```

**fail() 方法的參數：**

```javascript
$.ajax('/api/data')
.fail(function(jqXHR, textStatus, errorThrown) {
    // jqXHR: jQuery XMLHttpRequest 物件
    // textStatus: 字串，如 "error", "timeout", "abort"
    // errorThrown: 錯誤訊息字串
});
```

### Promise 方法的參數結構

**then() 方法的參數：**

```javascript
fetch('/api/data')
.then(function(response) {
	// fetch() 回傳 Promise<Response>
    // response: Response 物件（需要進一步解析）
    
    return response.json();
    // 取得回應內容：從 Response 物件中讀取 HTTP 回應的 body 內容
    // 解析 JSON：將回應內容（通常是 JSON 字串）解析成 JavaScript 物件
    // 回傳 Promise：這是一個非同步操作，所以回傳 Promise
})
.then(function(data) {
    // data: 解析後的資料
});
```

**catch() 方法的參數：**

```javascript
Promise.reject(new Error('錯誤'))
.catch(function(error) {
    // error: Error 物件或任何被 reject 的值
});
```

## 第三章：資料傳遞機制的重要差異

### done() 的直接傳遞機制

jQuery 的 `done()` 方法採用直接傳遞機制，不會自動解析 Promise 物件：

```javascript
$.ajax('/api/data')
.done(function(data) {
    console.log('第一個 done:', data); // 原始 AJAX 回應資料
    return Promise.resolve('done 回傳的 Promise');
})
.done(function(result) {
    console.log('第二個 done:', result); // 接收到 Promise 物件本身
    console.log('是否為 Promise:', result instanceof Promise); // true
});
```

這個機制的特點是每個 `done()` 直接接收上一個 `done()` 的回傳值，無論是一般值還是 Promise 物件。

### then() 的自動解析機制

jQuery 的 `then()` 方法會自動解析 Promise 物件：

```javascript
$.ajax('/api/data')
.done(function(data) {
    return Promise.resolve('解析我');
})
.then(function(result) {
    console.log('then 接收到:', result); // '解析我'（已解析）
    console.log('資料型態:', typeof result); // 'string'
});
```

這個機制確保了 `then()` 總是接收到解析後的值，而不是 Promise 物件本身。

## 第四章：錯誤處理的關鍵差異

### fail() 方法的特殊性質

這是最重要的發現：**fail() 的回傳值不會改變 Promise 鏈的狀態**。這是 jQuery Deferred 與原生 Promise 最大的差異之一。

```javascript
$.ajax('/nonexistent-endpoint') // 產生 404 錯誤
.fail(function(jqXHR, textStatus, errorThrown) {
    console.log('fail 執行:', textStatus); // 會顯示 "error"
    return { handled: true, data: '嘗試恢復的值' }; // 這個回傳值無效
})
.then(function(result) {
    console.log('then 不會執行'); // 確實不會執行
})
.catch(function(error) {
    console.log('catch 會執行'); // 會接收原始的 AJAX 錯誤
});
```

### catch() 方法的恢復能力

相對地，`catch()` 方法可以透過回傳值來恢復 Promise 鏈的狀態：

```javascript
$.ajax('/nonexistent-endpoint')
.catch(function(error) {
    console.log('catch 處理錯誤:', error);
    return { handled: true, data: '恢復值' }; // 這個回傳值有效
})
.then(function(result) {
    console.log('then 會執行:', result); // 會顯示恢復的值
});
```

### then() 錯誤回調的恢復能力

如果要在 jQuery 中實現類似 `catch()` 的恢復功能，可以使用 `then()` 的第二個參數：

```javascript
$.ajax('/nonexistent-endpoint')
.then(
    function(data) {
        // 成功回調
        console.log('成功:', data);
        return data;
    },
    function(jqXHR, textStatus, errorThrown) {
        // 錯誤回調 - 這裡的 return 可以恢復狀態
        console.log('錯誤處理:', textStatus);
        return { handled: true, data: '預設值' };
    }
)
.then(function(result) {
    console.log('這裡會執行:', result); // 會顯示恢復的值
});
```

## 第五章：return 和 throw 的包裝機制

### jQuery 傳統方法的行為

`done()`, `fail()`, `always()` 這些傳統方法不會自動將回傳值包裝成 Promise：

```javascript
$.ajax('/api/data')
.done(function(data) {
    return data.processed; // 直接回傳值，不包裝
})
.done(function(result) {
    console.log(result); // 直接接收上一個 done 的回傳值
});
```

### jQuery Promise 方法的行為

`then()`, `catch()`, `finally()` 這些方法會自動包裝回傳值：

```javascript
$.ajax('/api/data')
.then(function(data) {
    return data.processed; // 自動包裝成 Promise.resolve(data.processed)
})
.then(function(result) {
    console.log(result); // 接收解析後的值
});

// 即使沒有明確 return，也會包裝成 Promise.resolve(undefined)
$.ajax('/api/data')
.then(function(data) {
    console.log(data); // 沒有 return 語句
})
.then(function(result) {
    console.log(result); // undefined，但來自 Promise.resolve(undefined)
});
```

## 第六章：AJAX 錯誤的執行流程

### 實際測試結果

經過實際測試，當 AJAX 請求失敗時：

```javascript
$.ajax('/nonexistent-endpoint')
.done(function(data) {
    console.log('done: 不會執行'); // AJAX 失敗時不執行
})
.fail(function(jqXHR, textStatus, errorThrown) {
    console.log('fail: 會執行'); // 總是會執行
    // 無論這裡是否拋出錯誤，catch 都會執行
})
.catch(function(error) {
    console.log('catch: 也會執行'); // 總是會執行
});
```

重要發現：無論 `fail()` 是否拋出錯誤，`catch()` 都會執行，因為原始的 AJAX 錯誤會傳播到整個 Promise 鏈。

### 錯誤恢復的正確方式

如果需要從錯誤中恢復，應該使用能夠改變 Promise 狀態的方法：

```javascript
// 方式一：使用 catch()
$.ajax('/api/data')
.catch(function(error) {
    console.log('處理錯誤並恢復');
    return getDefaultData(); // 這會讓後續的 then() 執行
})
.then(function(data) {
    console.log('使用恢復的資料:', data);
});

// 方式二：使用 then() 的錯誤回調
$.ajax('/api/data')
.then(null, function(error) {
    console.log('處理錯誤並恢復');
    return getDefaultData(); // 這也會讓後續的 then() 執行
})
.then(function(data) {
    console.log('使用恢復的資料:', data);
});
```

## 第七章：版本差異與最佳實踐

### Portal 系統（jQuery 3.3.1）的建議

由於使用較新版本的 jQuery，建議優先使用現代的 Promise 方法：

```javascript
// 推薦的錯誤處理模式
$.ajax({
    url: '/api/users',
    type: 'GET',
    timeout: 5000
})
.then(function(users) {
    return processUsers(users);
})
.catch(function(error) {
    console.error('請求失敗:', error);
    return getDefaultUsers(); // 提供預設值
})
.then(function(finalUsers) {
    renderUsers(finalUsers); // 使用最終的使用者資料
});

// 如需詳細錯誤資訊，可以混合使用
$.ajax('/api/data')
.fail(function(jqXHR, textStatus, errorThrown) {
    // 記錄詳細的錯誤資訊
    logError({
        status: jqXHR.status,
        statusText: textStatus,
        error: errorThrown,
        responseText: jqXHR.responseText
    });
})
.catch(function(error) {
    // 提供使用者友善的錯誤處理
    showUserMessage('資料載入失敗，請稍後再試');
    return getDefaultData();
});
```

### GTS 系統（jQuery 1.10.2）的建議

由於使用較舊版本，建議主要使用傳統的 Deferred 方法：

```javascript
// 傳統但穩定的模式
$.ajax({
    url: '/api/data',
    type: 'POST',
    data: requestData,
    dataType: 'json'
})
.done(function(response, textStatus, jqXHR) {
    if (response.success) {
        processData(response.data);
    } else {
        handleBusinessError(response.message);
    }
})
.fail(function(jqXHR, textStatus, errorThrown) {
    var errorMessage = '請求失敗: ' + textStatus;
    if (jqXHR.responseJSON && jqXHR.responseJSON.message) {
        errorMessage += ' - ' + jqXHR.responseJSON.message;
    }
    showErrorMessage(errorMessage);
})
.always(function() {
    hideLoadingSpinner();
});
```

## 第八章：實務開發建議

### 統一的錯誤處理策略

在實際開發中，建議建立統一的錯誤處理機制：

```javascript
// 建立統一的 AJAX 封裝函數
function makeRequest(options) {
    var defaultOptions = {
        timeout: 10000,
        cache: false
    };
    
    var finalOptions = $.extend({}, defaultOptions, options);
    
    return $.ajax(finalOptions)
    .catch(function(error) {
        // 統一的錯誤記錄
        console.error('AJAX Error:', {
            url: finalOptions.url,
            method: finalOptions.type || 'GET',
            error: error
        });
        
        // 根據錯誤類型提供不同的預設值
        if (error.status === 401) {
            redirectToLogin();
            return Promise.reject('未授權');
        } else if (error.status >= 500) {
            showSystemErrorMessage();
            return getEmptyResponse();
        } else {
            showUserErrorMessage('操作失敗，請稍後再試');
            return getEmptyResponse();
        }
    });
}

// 使用封裝的函數
makeRequest({
    url: '/api/users',
    type: 'GET'
})
.then(function(users) {
    renderUserList(users);
});
```

### 偵錯與測試建議

在開發過程中，可以使用以下方式來驗證錯誤處理邏輯：

```javascript
// 測試不同的錯誤情況
function testErrorHandling() {
    console.log('開始測試錯誤處理...');
    
    // 測試網路錯誤
    $.ajax('/nonexistent-endpoint')
    .fail(function(jqXHR, textStatus, errorThrown) {
        console.log('網路錯誤 - fail:', textStatus);
    })
    .catch(function(error) {
        console.log('網路錯誤 - catch:', error);
    });
    
    // 測試邏輯錯誤
    $.ajax('/api/data')
    .then(function(data) {
        if (!data.isValid) {
            throw new Error('資料驗證失敗');
        }
        return data;
    })
    .catch(function(error) {
        console.log('邏輯錯誤:', error.message);
    });
}
```

## 總結與重點回顧

這次的學習讓我們深入理解了 jQuery Deferred 與 Promise 的差異，特別是以下幾個關鍵點：

**第一個重點**是 `fail()` 方法無法透過回傳值來改變 Promise 鏈的狀態。這與原生 Promise 的 `catch()` 方法形成鮮明對比，是實務開發中需要特別注意的地方。

**第二個重點**是 `then()` 方法會自動解析 Promise 物件，而 `done()` 方法則是直接傳遞回傳值。這個差異影響了我們在鏈式呼叫中處理資料的方式。

**第三個重點**是在錯誤恢復策略上，應該使用 `catch()` 方法或 `then()` 的錯誤回調，而不是依賴 `fail()` 的回傳值。

在華碩的兩個系統開發中，Portal 系統可以充分利用現代 Promise 的特性，而 GTS 系統則需要更多地依賴傳統的 Deferred 方法。無論使用哪種方式，重要的是保持程式碼的一致性和可讀性，並建立完善的錯誤處理機制來確保應用程式的穩定性。