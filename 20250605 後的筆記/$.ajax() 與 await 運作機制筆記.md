---
date: 2025-07-08 18:29
aliases: 
tags:
  - jQuery
  - AJAX
  - async/await
---
# Metadata
Status :: 🌱
Note Type :: 📰
Source URL :: {文章 URL}
Author :: {作者名稱}
Topics :: {筆記跟什麼主題有關，用 `[Topic],[Topic]` 格式}

---
# 連結筆記
#### 📑 [[$.ajax() deferred (Promise-like)  vs  Javascript Promise (學得很混淆)]]
#### 📑 [[歡迎]]

---

## 問題起源

從這個問題開始：

- `$.ajax` 成功時是傳什麼出來，`await` 又是取什麼？
- `$.ajax` 失敗時是傳什麼出來，系統是如何知道應該要觸發 `catch` 了？

## 核心概念

### 1. jQuery Deferred 物件的特性

- `$.ajax()` 回傳的是 **jQuery Deferred 物件**，不是標準 Promise
- Deferred 物件同時實作了：
    - **jQuery 介面**：`.done()`, `.fail()`, `.always()`
    - **Promise 介面**：`.then()`, `.catch()` (thenable)
- **沒有「轉型」過程**，從一開始就支援兩種介面

### 2. 成功時的流程

```javascript
// jQuery 內部機制
deferred.resolve(data, textStatus, jqXHR)
    ↓ 
// 當使用 Promise 介面時（如 await）
Promise.resolve(data)  // 只保留第一個參數
    ↓
// await 的結果
await 取得 data（API 回傳的資料）
```

**重點：** `await $.ajax()` 取得的是 **API 回傳的資料本身**

### 3. 失敗時的流程

```javascript
// jQuery 內部機制
deferred.reject(jqXHR, textStatus, errorThrown)
    ↓
// 當使用 Promise 介面時（如 await）
Promise.reject(jqXHR)  // 只保留第一個參數
    ↓
// catch 的結果
catch 接收到 jqXHR 物件
```

**重點：** `catch` 接收到的是 **jqXHR 物件**，不是 Error 物件

### 4. 系統如何知道觸發 catch？

jQuery 根據以下條件決定是 resolve 還是 reject：

- **成功條件**：HTTP 狀態碼 200-299
- **失敗條件**：
    - HTTP 狀態碼 >= 400（如 404、500）
    - 網路錯誤（連線逾時、無法連接）
    - 解析錯誤（預期 JSON 但收到 HTML）

## 實際範例對比

### 原始 Promise 包裝方式

```javascript
function ajaxPromise(options) {
    return new Promise((resolve, reject) => {
        $.ajax(options)
            .done((data, textStatus, jqXHR) => {
                resolve(data);    // 標準 Promise.resolve(data)
            })
            .fail((jqXHR, textStatus, errorThrown) => {
                const error = new Error(`Ajax Error: ${jqXHR.status}`);
                error.jqXHR = jqXHR;
                reject(error);    // 標準 Promise.reject(Error)
            });
    });
}
```

### 直接使用 async/await 方式

```javascript
async function ajaxPromise(options) {
    try {
	    // await 會把 jQuery Promise 轉成原生 Promise，丟失額外參數
        const result = await $.ajax(options);  // 取得 data
        return result;
    } catch (jqXHR) {                          // 接收 jqXHR
        const error = new Error(`Ajax Error: ${jqXHR.status}`);
        error.jqXHR = jqXHR;
        throw error;
    }
}
```

**這兩種方式功能完全相同！**

## 關鍵差異說明

### 標準 Promise 行為

```javascript
// 標準 Promise
const standardPromise = new Promise((resolve, reject) => {
    resolve(data);           // await 取得 data
    reject(new Error());     // catch 取得 Error 物件
});
```

### jQuery ajax 行為

```javascript
// jQuery ajax 的特殊行為
$.ajax()
    .done(data, textStatus, jqXHR)     // 成功：傳遞三個參數
    .fail(jqXHR, textStatus, errorThrown)  // 失敗：傳遞三個參數

// 但轉換成 Promise 介面時
await $.ajax()  // 只取得第一個參數 data
catch(jqXHR)    // 只取得第一個參數 jqXHR
```

## 為什麼可以同時使用兩種語法？

```javascript
// 同一個 Deferred 物件可以同時使用：
const ajaxRequest = $.ajax({ url: '/api/data' });

// jQuery 介面
ajaxRequest.done(data => console.log('done:', data));
ajaxRequest.fail(jqXHR => console.log('fail:', jqXHR));

// Promise 介面
ajaxRequest.then(data => console.log('then:', data));
ajaxRequest.catch(jqXHR => console.log('catch:', jqXHR));

// 鏈式呼叫
$.ajax({ url: '/api/data' })
    .done(data => console.log('done'))
    .fail(jqXHR => console.log('fail'))
    .then(data => console.log('then'))
    .catch(jqXHR => console.log('catch'));
```

## await 可以使用的原因

JavaScript 的 `await` 會檢查物件是否為 **thenable**（有 `.then()` 方法）：

```javascript
// 當你寫 await $.ajax() 時
const ajaxRequest = $.ajax({ url: '/api/data' });
if (typeof ajaxRequest.then === 'function') {
    // 可以 await，因為有 .then() 方法
    const result = await ajaxRequest;
}
```

## 總結

1. **jQuery Deferred 同時實作兩種介面**，沒有轉型過程
2. **成功時**：`await` 取得 API 回傳的資料
3. **失敗時**：`catch` 接收到 jqXHR 物件
4. **觸發 catch**：根據 HTTP 狀態碼和網路狀況決定
5. **現代用法**：可以直接用 `await $.ajax()` 取代手動 Promise 包裝

這就是為什麼你的 async/await 改寫完全正確，且比原始的 Promise 包裝方式更簡潔！