---
title: 'c# 非同步筆記草稿'

---

每一個 Task 物件即封裝了一項非同步執行的工作。這很像是委派（delegate）的概念——委派不也封裝了一項任務嗎？兩者的差別在於，委派是以同步的（synchronous）方式執行，而 Task 是以非同步的方式來執行其封裝的工作。

一個由 Task 所代表的非同步工作是由「工作排程器」（task scheduler）來安排執行時機。說得更精確些，所有需要動用執行緒的工作（thread-based tasks）都是由工作排程器來執行

預設情況下，工作排程器會從執行緒集區提取一個工作執行緒worker thread）來執行工作。.NET 執行緒集區會負責判斷如何分配執行緒以便獲得更高的執行效能，以及是否要創建一個新的執行緒、或是重複使用已經結束工作、處於閒置狀態的執行緒。

預設情況下，執行緒集區裡面的執行緒都是「背景執行緒」，故此範例執行時，背景工作MyTask 可能還沒跑完，便因為主執行緒的結束而隨之結束。如果要等待某個非同步工作執行完畢，可呼叫 Task 類別的 Wait 方法。

你「可以」使用 Task 的 Wait 或其他方法來等待非同步工作的結果，但這不是建議作法，也不代表你可以隨意使用。事實上，除非必要，否則應該儘量避免使用這類會令非同步工作流阻塞的 API。

你的應用程式用的執行緒數量越多，ASP.NET 能用來處理用戶端 HTTP 請求的執行緒數量就越少。不過，.NET 4.5 已針對此狀況做了改進：CLR 會偵測執行緒集區裡面的執行緒是否不夠用，並且視需要加入新的執行緒（當然，集區大小還是有上限的，這點前面已經提過）。

一個 CLR 有一個執行緒集區。故一般而言，一個 .NET 應用程式有一個自己專屬的執行緒集區（除非它會載入多個 CLR）。
• CLR 實作的執行緒集區分成兩種：工作執行緒集區和 I/O 執行緒集區。前者大多用來處理CPU 運算類型的工作，後者專用於 I/O 操作。
• .NET 應用程式的執行緒可分為兩種：前景執行緒和背景執行緒。兩者的主要區別是：當所有的前景執行緒停止時，應用程式就會結束，並且停止所有背景執行緒。若只是停止背景執行緒，則不會造成應用程式結束。此外，雖然結束應用程式時，.NET 會通知所有的背景執行緒停止，但比較保險的做法還是自行結束背景執行緒。
• 本章提及的幾種非同步程式設計方法，它們在 .NET 版本演進過程中出現的順序如下：
– .NET 1.0：專屬執行緒（Thread 類別）、執行緒集區（ThreadPool 類別）。
– .NET 4.0：TPL（Task Parallel Library）。
– .NET 4.5：TAP（Task-based Asynchronous Pattern），C# 5 的 async 與 await 寫法。
• 使用 TPL 的 Task 相關類別來建立非同步工作時，往往代表背後會使用執行緒。因為 TPL 的預設工作排程器會透過執行緒集區來獲取工作執行緒。
• 並非所有的非同步呼叫都會動用執行緒。

現行 .NET 平台上面所建議使用的非同步程式設計模型 TAP（Task-based Asynchronous Programming）是基於 TPL（Task Parallel Library）這組 API，而它們的最重要核心則是用來代表非同步工作的 Task 類別（及其子類別Task<TResult>）。至於 C# 的 async 與 await 關鍵字，則可以說是讓非同步程式更容易撰寫與閱讀的語法糖。

TPL 的 Task 物件即代表「非同步工作」，但不等同於「執行緒」——使用 Task 物件時，CLR 會自動幫你管理執行緒，這樣你就不用透過 Thread 類別去處理許多與執行緒管理的瑣碎細節。

非同步方法若不需要傳回值，則回傳型別應寫成 Task，而不要寫 void（原因後述）。
非同步方法雖然可以宣告為 void，但此寫法通常只用於事件處理常式。一般而言，應避免使用 void 來宣告沒有回傳值的非同步方法。
無回傳值的非同步方法不應宣告為 async void 的一個重要原因，是這種寫法會令呼叫端捕捉不到非同步方法所拋出的異常。參考以下範例：

使用了關鍵字 await 的地方會暫且記住 await 敘述所在的位置，並且令程式控制流程立刻返回呼叫端繼續往下執行；直到呼叫端需要取得非同步工作的執行結果時，控制流才又會回到剛剛 await 暫且保留而未執行的程式碼，等待那個非同步工作執行完畢，並傳回其執行結果。

有用到 await 的函式都必須在宣告時加上 async 關鍵字

在宣告方法時加上關鍵字 async，即表示它是個非同步方法。其實 async 的作用也真的就只有一個，那就是告訴編譯器：「這是個非同步方法，裡面可以、而且應該要使用關鍵字 await 來等待非同步工作的結果。」

以 async 關鍵字修飾的方法，其傳入參數有個規則：不可使用 ref 或 out 修飾詞。若違反此規則，程式將無法通過編譯。稍微想一下，此限制的確合理，畢竟非同步方法返回呼叫端時，可能還有程式碼尚未執行完畢，亦即輸出參數的值不見得已經設定好，故對於呼叫端而言不具意義。

有用到 await 關鍵字的函式，必須在宣告函式時加上對應的關鍵字 async，並將回傳型別改成 Task、Task<T> 或相似的型別（例如 ValueTask<T>）。

程式的控制流一開始進入 async 方法時，仍是以同步的方式執行，而且是執行於呼叫端所在的控制流；直到碰到 await 敘述，控制流才開始分開。基本上，await 之前的程式碼是一個同步執行的程式區塊，而 await 敘述之後的程式碼則為另一個同步執行的程式區塊。

碰到 await 關鍵字時，會先獲取當時的同步環境（AsynchronousContext），並記住稍後要回來繼續執行的地方，然後立刻返回呼叫端。等到 await 所等待的非同步工作執行完畢之後，控制流才又從原先保留的地方恢復執行。

存取 Task 物件的 Result 屬性就會擋住（block）目前的執行緒，一直等到那個非同步工作完成並傳回結果，才能繼續往下執行。最好盡量避免使用 Task.Result 這種阻斷式操作。

一旦使用了非同步呼叫，應從頭到尾都是非同步，而不要中途由非同步呼叫改成同步（阻斷式）呼叫。
    
請注意 await 等待的是某個方法所回傳的 Task 物件，而不管那個方法是不是 async 方法。因此，
在介面中定義方法時，只要它回傳的物件類型是 Task 或 Task<T>，該物件便可以被 await。